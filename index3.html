<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tic Tac Toe</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(3, 80px);
      grid-gap: 5px;
      margin-top: 20px;
    }
    .cell {
      width: 80px;
      height: 80px;
      font-size: 24px;
      cursor: pointer;
      border: 1px solid #ccc;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }
    .cell:hover {
      background-color: #f0f0f0;
    }
    .win-cell {
      background-color: #6aff6a;
    }
    .winner-symbol {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border: 3px solid black;
      padding: 5px;
      box-sizing: border-box;
    }
    .win-line {
      position: absolute;
      z-index: 1;
      background-color: black;
    }
    #message {
      margin-top: 20px;
      font-size: 18px;
    }
    #scoreboard {
      margin-top: 20px;
      font-size: 20px;
    }
    .button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <h1>Tic Tac Toe</h1>
  <div id="board"></div>
  <div id="message"></div>
  <div id="scoreboard"></div>
  <button class="button" onclick="setLevel(1)">Level 1</button>
  <button class="button" onclick="setLevel(2)">Level 2</button>
  <button class="button" onclick="setLevel(3)">Level 3</button>
  <button class="button" onclick="restartGame()">Restart Game</button>
  <button class="button" onclick="resetGame()">Reset Game & Scoreboard</button>
  <script>
    let board = ['', '', '',
                 '', '', '',
                 '', '', ''];
    let currentPlayer = 'X';
    let gameOver = false;
    let score = { 'X': 0, 'O': 0 };
    let winLine = null;
    let markWinner = false;

    let difficultyLevel = 2;

    const winPatterns = [
      [0, 1, 2], [3, 4, 5], [6, 7, 8],
      [0, 3, 6], [1, 4, 7], [2, 5, 8],
      [0, 4, 8], [2, 4, 6]
    ];

    const cells = document.querySelectorAll('.cell');
    const message = document.getElementById('message');
    const scoreboard = document.getElementById('scoreboard');

    function initGame() {
      board = ['', '', '',
               '', '', '',
               '', '', ''];
      gameOver = false;
      winLine = null;
      renderBoard();
      message.textContent = '';

      if (difficultyLevel === 3 && currentPlayer === 'O' && !gameOver) {
        setTimeout(computerMove, 500);
      }
    }

    function renderBoard() {
      document.getElementById('board').innerHTML = board.map((value, index) => {
        let className = 'cell';
        if (markWinner && winLine && winLine.includes(index)) {
          className += ' win-cell';
        }
        return `<div class="${className}" onclick="cellClicked(${index})">${value}</div>`;
      }).join('');
      if (markWinner && winLine) {
        drawWinLine();
      } else {
        clearWinLine();
      }
    }

    function drawWinLine() {
      const [a, b, c] = winLine;
      const cellA = document.querySelector(`#board .cell:nth-child(${a + 1})`);
      const cellB = document.querySelector(`#board .cell:nth-child(${b + 1})`);
      const cellC = document.querySelector(`#board .cell:nth-child(${c + 1})`);

      const centerX = (cellA.offsetLeft + cellB.offsetLeft + cellC.offsetLeft) / 3;
      const centerY = (cellA.offsetTop + cellB.offsetTop + cellC.offsetTop) / 3;

      const angle = Math.atan2(cellA.offsetTop - cellB.offsetTop, cellA.offsetLeft - cellB.offsetLeft) * 180 / Math.PI;

      const length = Math.sqrt(Math.pow(cellA.offsetTop - cellB.offsetTop, 2) + Math.pow(cellA.offsetLeft - cellB.offsetLeft, 2));

      const line = document.createElement('div');
      line.className = 'win-line';
      line.style.width = `${length}px`;
      line.style.height = '3px';
      line.style.backgroundColor = 'black';
      line.style.position = 'absolute';
      line.style.top = `${centerY}px`;
      line.style.left = `${centerX}px`;
      line.style.transform = `rotate(${angle}deg)`;
      document.body.appendChild(line);
    }

    function clearWinLine() {
      const existingLine = document.querySelector('.win-line');
      if (existingLine) {
        existingLine.parentNode.removeChild(existingLine);
      }
    }

    function cellClicked(index) {
      if (board[index] || gameOver) return;

      board[index] = currentPlayer;
      renderBoard();

      if (checkWinner(currentPlayer)) {
        if (currentPlayer === 'X') {
          message.textContent = `You won!`;
          score[currentPlayer]++;
        } else {
          message.textContent = `You lost!`;
          score['O']++;
        }
        updateScoreboard();
        gameOver = true;
        toggleWinnerMarking(); // Automatically toggle marking the winner
        return;
      }

      if (board.every(cell => cell)) {
        message.textContent = "It's a draw!";
        gameOver = true;
        setTimeout(restartGame, 1000);
        return;
      }

      currentPlayer = currentPlayer === 'X' ? 'O' : 'X';

      if (currentPlayer === 'O' && !gameOver) {
        setTimeout(computerMove, 500);
      }
    }

    function computerMove() {
      let availableMoves = board.reduce((acc, cell, index) => {
        if (!cell) acc.push(index);
        return acc;
      }, []);

      let computerIndex;
      if (difficultyLevel === 1) {
        computerIndex = availableMoves[Math.floor(Math.random() * availableMoves.length)];
      } else if (difficultyLevel === 2) {
        computerIndex = getBestMoveMedium();
      } else if (difficultyLevel === 3) {
        computerIndex = getBestMoveHard();
      }

      cellClicked(computerIndex);
    }

    function getBestMoveMedium() {
      // Medium difficulty: Attempt to block player winning moves or win if possible, else prioritize moves that contribute to completing a row, column, or diagonal
      for (let pattern of winPatterns) {
        let playerMoves = pattern.filter(index => board[index] === 'X');
        if (playerMoves.length === 2) {
          for (let index of pattern) {
            if (board[index] === '') return index; // Block player's winning move
          }
        }
      }

      for (let pattern of winPatterns) {
        let computerMoves = pattern.filter(index => board[index] === 'O');
        if (computerMoves.length === 2) {
          for (let index of pattern) {
            if (board[index] === '') return index; // Win if possible
          }
        }
      }

      // Prioritize moves that contribute to completing a row, column, or diagonal
      for (let pattern of winPatterns) {
        let emptyCells = pattern.filter(index => board[index] === '');
        if (emptyCells.length === 1) {
          return emptyCells[0];
        }
      }

      return availableMoves[Math.floor(Math.random() * availableMoves.length)]; // Random move if no immediate winning, blocking, or completing moves
    }

    function getBestMoveHard() {
      // Hard difficulty: Use minimax algorithm for best move
      let bestScore = -Infinity;
      let move;

      for (let i = 0; i < 9; i++) {
        if (board[i] === '') {
          board[i] = 'O';
          let score = minimax(board, 0, false);
          board[i] = '';
          if (score > bestScore) {
            bestScore = score;
            move = i;
          }
        }
      }

      return move;
    }

    function minimax(board, depth, isMaximizing) {
      let result = checkResult();
      if (result !== null) {
        return result;
      }

      if (isMaximizing) {
        let bestScore = -Infinity;
        for (let i = 0; i < 9; i++) {
          if (board[i] === '') {
            board[i] = 'O';
            let score = minimax(board, depth + 1, false);
            board[i] = '';
            bestScore = Math.max(score, bestScore);
          }
        }
        return bestScore;
      } else {
        let bestScore = Infinity;
        for (let i = 0; i < 9; i++) {
          if (board[i] === '') {
            board[i] = 'X';
            let score = minimax(board, depth + 1, true);
            board[i] = '';
            bestScore = Math.min(score, bestScore);
          }
        }
        return bestScore;
      }
    }

    function checkResult() {
      for (let pattern of winPatterns) {
        let [a, b, c] = pattern;
        if (board[a] !== '' && board[a] === board[b] && board[b] === board[c]) {
          if (board[a] === 'O') {
            winLine = pattern;
            return 1; // Computer wins
          } else {
            winLine = pattern;
            return -1; // Player wins
          }
        }
      }
      if (board.every(cell => cell !== '')) {
        return 0; // Draw
      }
      return null; // Game not ended
    }

    function updateScoreboard() {
      scoreboard.textContent = `Score: X - ${score['X']} | O - ${score['O']}`;
    }

    function restartGame() {
      initGame();
      updateScoreboard();
    }

    function resetGame() {
      score['X'] = 0;
      score['O'] = 0;
      restartGame();
    }

    function setLevel(level) {
      difficultyLevel = level;
      if (difficultyLevel === 3) {
        currentPlayer = 'O';
        computerMove();
      } else {
        currentPlayer = 'X';
      }
      restartGame();
    }

    function toggleWinnerMarking() {
      markWinner = !markWinner;
      renderBoard();
    }

    initGame();
  </script>
</body>
</html>
